# <a name="finish"></a>finish()




Сразу после создания объекта ServiceScope он находится в "незавершенном" состоянии, в котором разрешено вызывать метод provide(), но запрещено вызывать метод consume(). После вызова метода finish() метод consume() будет разрешен, а метод provide() — запрещен. Такой формализм полностью устраняет ряд сложных ошибок, одна из которых описывается ниже. Scope2 — дочерний объект области Scope1, а Scope1 предоставляет экземпляр A1 интерфейса A. Если кто-нибудь использует A1 из Scope2 (путем наследования) перед вызовом метода Scope2.provide() с помощью A2, то при последующем вызове метода Scope2.consume() может возвращаться не такой результат, как при предыдущем. Это может создавать сложности для разработчиков.

**Подпись:** _public finish(): void;_

**Возвращаемое значение**: `void`





#### <a name="parameters"></a>Параметры
Нет


