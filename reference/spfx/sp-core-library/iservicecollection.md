<span data-ttu-id="8b817-p101">Многоразовые компоненты библиотеки обычно объявляют свои зависимости служб, вызывая метод ServiceScope.consume() с помощью соответствующего объекта ServiceKey для каждой службы. Для бизнес-логики приложений или небольших проектов такой формализм может быть излишним и увеличивать время, которое требуется на обучение разработчиков. Шаблон IServiceCollection позволяет передавать общие службы для определенного сценария в виде простой, удобной коллекции. Например, функция виджета может добавлять следующий интерфейс: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } После этого класс Widget может инициализировать свойство services следующим образом: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection { return this._services; } } Для группы компонентов, обладающих этими зависимостями, такой объект services можно передавать вместо абстрактного объекта ServiceScope. Это позволяет использовать прямые ссылки, например services.widgetManager, services.spHttpClient и т. д. Для нетипичных зависимостей можно использовать класс services.serviceScope. ВАЖНО! Чтобы шаблон был удобным и понятным, НЕ следует добавлять в интерфейс IServiceCollection элементы, не являющиеся службами ServiceScope.</span><span class="sxs-lookup"><span data-stu-id="8b817-p101">Reusable library components typically declare their service dependencies by calling ServiceScope.consume() using the corresponding ServiceKey for each service. For application business logic or small-sized projects, this formalism may be unnecessary and would increase the learning curve for developers. As a lightweight alternative, the IServiceCollection pattern allows the common services for a particular scenario to be passed around as a simple, convenient collection. For example, a widget feature might introduce an interface like this: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } Then the Widget class might initialize a "services" property, like this: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection { return this._services; } } For a group of components that all have these dependencies, this "services" object can be passed around instead of the abstract ServiceScope. This enables direct references such as services.widgetManager, services.spHttpClient, etc. For atypical dependencies, the services.serviceScope is still available for use. IMPORTANT: To keep the pattern clean and understandable, IServiceCollection should NOT be extended with any additional members that are not ServiceScope services.</span></span>

Многоразовые компоненты библиотеки обычно объявляют свои зависимости служб, вызывая метод ServiceScope.consume() с помощью соответствующего объекта ServiceKey для каждой службы. Для бизнес-логики приложений или небольших проектов такой формализм может быть излишним и увеличивать время, которое требуется на обучение разработчиков. Шаблон IServiceCollection позволяет передавать общие службы для определенного сценария в виде простой, удобной коллекции. Например, функция виджета может добавлять следующий интерфейс: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } После этого класс Widget может инициализировать свойство services следующим образом: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection { return this._services; } } Для группы компонентов, обладающих этими зависимостями, такой объект services можно передавать вместо абстрактного объекта ServiceScope. Это позволяет использовать прямые ссылки, например services.widgetManager, services.spHttpClient и т. д. Для нетипичных зависимостей можно использовать класс services.serviceScope. ВАЖНО! Чтобы шаблон был удобным и понятным, НЕ следует добавлять в интерфейс IServiceCollection элементы, не являющиеся службами ServiceScope.

