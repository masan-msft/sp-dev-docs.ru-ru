---
title: "Расширение конфигурации Webpack в цепочке инструментов SharePoint Framework"
ms.date: 09/25/2017
ms.prod: sharepoint
ms.openlocfilehash: c5156ce434a791658de3798ff0d7de2e73c42fb2
ms.sourcegitcommit: 1cae27d85ee691d976e2c085986466de088f526c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2017
---
# <a name="extending-webpack-in-the-sharepoint-framework-toolchain"></a>Расширение конфигурации Webpack в цепочке инструментов SharePoint Framework

[Webpack](https://Webpack.js.org/) — это средство увязки модулей JavaScript в пакеты. На основе выбранных вами файлов JavaScript и их зависимостей это средство создает один или несколько файлов JavaScript, чтобы можно было загружать различные части кода для различных сценариев.

Для увязки файлов в пакеты цепочка инструментов платформы использует CommonJS. Это позволяет определять модули и указывать, где вы хотите использовать их. Кроме того, цепочка инструментов использует SystemJS (универсальный загрузчик модулей) для загрузки ваших модулей. Благодаря этому можно задавать области для веб-частей и гарантировать, что каждая веб-часть будет выполняться в ее собственном пространстве имен.

Одна из стандартных задач, которую вам, возможно, потребуется добавить в цепочку инструментов SharePoint Framework, — расширение конфигурации Webpack с использованием пользовательских загрузчиков и подключаемых модулей.

## <a name="using-webpack-loaders"></a>Использование загрузчиков Webpack
Во время разработки часто требуется импортировать и использовать ресурсы, не относящиеся к JavaScript, например изображения или шаблоны. [Загрузчик Webpack](https://webpack.js.org/loaders/) преобразовывает ресурс так, что его сможет использовать ваше приложение JavaScript, либо предоставляет простую ссылку, понятную для приложения JavaScript. Например, шаблон Markdown можно скомпилировать и преобразовать в текстовую строку, а ресурс изображения можно преобразовать во встроенное изображение в кодировке Base64. Кроме того, можно создать ссылку на ресурс изображения в виде URL-адреса и скопировать его в каталог `dist` для развертывания.

Существует целый ряд полезных загрузчиков. Некоторые из них уже используются в стандартной конфигурации Webpack в SharePoint Framework, например следующие:

- html-loader;
- json-loader;
- loader-load-themed-styles.

Расширение конфигурации Webpack платформы с использованием пользовательских загрузчиков — это понятный линейный процесс, описанный [в документации по Webpack](https://webpack.js.org/contribute/writing-a-loader/).

> Дополнительные сведения о загрузчиках см. в [документации по загрузчикам Webpack](https://webpack.js.org/loaders/)

## <a name="example-using-the-markdown-loader-package"></a>Пример: использование пакета markdown-loader
В качестве примера рассмотрим [пакет markdown-loader](https://www.npmjs.com/package/markdown-loader).  Это загрузчик, с помощью которого вы можете ссылаться на файл `.md` и выводить его в качестве строки HTML.

Готовый образец можно скачать [здесь](https://aka.ms/spfx-extend-Webpack-sample).

### <a name="step-1---install-the-package"></a>Этап 1. Установка пакета
Добавим в проект ссылку на пакет markdown-loader.

```
npm i --save markdown-loader
```

### <a name="step-2---configure-webpack"></a>Этап 2. Настройка Webpack
Теперь, когда у нас установлен пакет, давайте настроим конфигурацию Webpack для SharePoint Framework так, чтобы она включала пакет `markdown-loader`.

В [документации по пакету markdown-loader](https://github.com/peerigon/markdown-loader) показано, как расширить конфигурацию Webpack, чтобы она включала загрузчик:

```JavaScript
{
  module: {
    rules: [
      {
        test: /\.md$/,
        use: [
          {
            loader: 'html-loader'
          },
          {
            loader: 'markdown-loader',
            options: {
              /* options for markdown-loader here */
            }
          }
        ]
      }
    ]
  }
}
```

Давайте посмотрим, что делает эта конфигурация.
  - Массив `rules` в конфигурации Webpack определяет набор проверок путей к файлам и загрузчики, которые следует использовать при обнаружении ресурса, соответствующего условиям проверки. В этом случае свойство `test` выполняет проверку путей к файлам, которые заканчиваются на `.md`.
  - Массив `use` описывает список загрузчиков, которые последовательно применяются к ресурсу. Они применяются, начиная с последнего загрузчика и заканчивая первым. В данном случае первым будет применен загрузчик `markdown-loader`, а последним — `html-loader`.
  - Если указано несколько загрузчиков, результаты работы каждого загрузчика передаются следующему.

Мы будем использовать эти сведения для настройки загрузчика в нашем проекте.

Чтобы добавить этот пользовательский загрузчик в конфигурацию Webpack для SharePoint Framework, необходимо поручить задаче сборки настроить Webpack. Задачи сборки определены в файле gulp (`gulpfile.js`), который находится в корневой папке проекта.

Измените файл `gulpfile.js`, добавив следующий код перед строкой `build.initialize(gulp);`:

```JavaScript
build.configureWebpack.mergeConfig({
  additionalConfiguration: (generatedConfiguration) => {
    generatedConfiguration.module.rules.push(
      {
        test: /\.md$/,
        use: [
          {
            loader: 'html-loader'
          },
          {
            loader: 'markdown-loader'
          }
        ]
      }
    );

    return generatedConfiguration;
  }
});
```

Давайте разберем, что делает этот фрагмент кода.
  - Как следует из ее названия, задача `ConfigureWebpackTask` (как проиллюстрировано в примере `build.configureWebpack`) настраивает Webpack. Существует много особых конфигураций для сборки проектов SPFx, поэтому в данной задаче используется нетривиальная логика.
  - Задача `ConfigureWebpackTask` получает необязательное свойство `additionalConfiguration`. Нам необходимо настроить это свойство для функции, которая получает созданную конфигурацию, вносит в нее необходимые нам изменения, а затем возвращает измененную конфигурацию. **Обратите внимание, что эта функция должна обязательно возвращать конфигурацию Webpack в цепочку инструментов, в противном случае Webpack будет настроен неправильно.**
  - В теле функции, которую мы задали для `additionalConfiguration`, просто отправьте новое правило в существующий набор правил в конфигурации. Обратите внимание, что это новое правило очень похоже на пример в фрагменте конфигурации в начале **этапа 2**.

> Используя этот подход, вы можете полностью заменить конфигурацию Webpack, используемую по умолчанию в цепочке инструментов, но для достижения максимальной производительности и оптимизации не рекомендуется делать это, если иное не указано в документации.

### <a name="step-3---update-your-code"></a>Этап 3. Внесение изменений в код
Теперь, когда мы настроили загрузчик, давайте обновим код и добавим несколько файлов, чтобы протестировать сценарий.

Создайте файл `my-markdown.md` с текстом Markdown в каталоге `src` папки проекта.

```md
#Hello Markdown

*Markdown* is a simple markup format to write content.

You can also format text as **bold** or *italics* or ***bold italics***
```

При сборке проекта загрузчик markdown-loader Webpack преобразует этот текст в строку HTML. Чтобы использовать эту строку HTML в любом из ваших исходных файлов `*.ts`, добавьте следующую строку `require()` в начале файла после кода импорта:


```TypeScript
const markdownString: string = require<string>('./../../../../src/readme.md');
```

По умолчанию Webpack будет искать файл в папке `lib`, но по умолчанию файлы `.md` не копируются в папку `lib`, поэтому необходимо составить довольно длинный относительный путь. Мы можем изменить этот параметр, определив файл конфигурации, и сообщить цепочке инструментов, что необходимо скопировать файлы `md` в папку lib.

Создайте файл `copy-static-assets.json` в каталоге `config`, чтобы сообщить системе сборки, что необходимо скопировать некоторые дополнительные файлы из папки `src` в папку `lib`. По умолчанию эта задача сборки копирует файлы с расширениями, которые понятны конфигурации Webpack, используемой по умолчанию, цепочки инструментов (например, `png` и `json`), поэтому нам просто необходимо поручить ей скопировать файлы `md`.

```JSON
{
  "includeExtensions": [
    "md"
  ]
}
```

Теперь в операторе `require` вместо относительного пути можно использовать путь к файлу, например:

```TypeScript
const markdownString: string = require<string>('./../../readme.md');
```

Вы можете ссылаться на эту строку в коде, например:

``` TypeScript
public render(): void {
  this.domElement.innerHTML = markdownString;
}
```

### <a name="step-4---build-and-test-your-code"></a>Этап 4. Сборка и тестирование кода
Чтобы собрать и протестировать код, выполните в консоли следующую команду для корневого каталога проекта:

```
gulp serve
```
