---
title: "Выделение контента и расширение функций надстроек с размещением в SharePoint с помощью элемента \"Выноска\""
ms.date: 09/25/2017
ms.prod: sharepoint
ms.openlocfilehash: c58c5b988eb2aa65ca6f6efe4945e974bdd83059
ms.sourcegitcommit: 1cae27d85ee691d976e2c085986466de088f526c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2017
---
# <a name="highlight-content-and-enhance-the-functionality-of-sharepoint-hosted-sharepoint-add-ins-with-the-callout-control"></a>Выделение контента и расширение функций надстроек с размещением в SharePoint с помощью элемента "Выноска"
Элемент "Выноска" в SharePoint помогает привлечь внимание пользователя и продемонстрировать функции приложения, размещенного в SharePoint. Вы можете настраивать его различным образом в зависимости от требований к пользовательскому интерфейсу приложения. В этой статье рассказывается, как спроектировать такой элемент управления, добавить его на страницу, а также настроить его внешний вид и режим работы.
 
Выполняя поиск на сайте SharePoint, вы увидите примеры элемента управления "Выноска", так как он отображается каждый раз, когда вы наводите указатель на результат поиска. На рис. 1 показана выноска для отдельного результата поиска, а также представлено несколько типичных аспектов элемента управления контентом: заголовок, сведения об элементе на странице и действия (**Открыть** и **Отправить**), которые вы можете выполнить с этим элементом. В данном случае используются относительно простые сведения и действия, однако вы уже можете наблюдать два преимущества использования выноски: отображение дополнительных сведений об элементах на странице по мере необходимости и удобство добавления функций на страницу. 
 

**Рис. 1. Пример элемента управления "Выноска" на странице результатов поиска в SharePoint**

 

 
![Пример элемента управления "Выноска" на странице результатов поиска в SharePoint](../images/S15_CalloutControlExample.png)
 

 

 

 **Примечание.** В настоящее время идет процесс замены названия "приложения для SharePoint" названием "надстройки SharePoint". Во время этого процесса в документации и пользовательском интерфейсе некоторых продуктов SharePoint и средств Visual Studio может по-прежнему использоваться термин "приложения для SharePoint". Дополнительные сведения см. в статье [Новое название приложений для Office и SharePoint](new-name-for-apps-for-sharepoint.md#bk_newname).
 


## <a name="make-the-control-available-to-your-html-page-by-including-the-calloutjs-file"></a>Предоставление HTML-странице доступа к элементу управления путем добавления файла callout.js
<a name="GettingStarted"> </a>

В этом примере используется метод `SP.SOD.executeFunc`, чтобы гарантировать, что файл скрипта загрузится до выполнения какого-либо кода, ссылающегося на него.
 

 

```
SP.SOD.executeFunc("callout.js", "Callout", function () {
    });
```

Функция, которую вы передаете в функцию  `SP.SOD.executeFunc`, содержит код, который вы хотите выполнить после загрузки файла callout.js. Когда эти файлы загрузятся, используйте объект  `CalloutManager`, чтобы создать объект  `Callout` для каждого элемента страницы, которому требуется иметь сопоставленный с ним элемент управления выносками. `CalloutManager` это одноэлементный объект, хранящий ссылки на каждый объект `Callout` на странице внутри массива ассоциативных элементов. Объект `Callout` имеет всего два обязательных члена: `ID` и `launchPoint`. Член  `ID` это ключ, сопоставленный с объектом `Callout` в `CalloutManager`:  `CalloutManager["value of the callout's ID member"]`. Член  `launchPoint` это элемент HTML-страницы. Вы можете, например, создать или получить элемент `div` на своей странице и передать его в качестве члена объекта `Callout`. По умолчанию элемент управления выносками отображается при щелчке пользователем элемента  `launchPoint`. В этом примере показано, как создать простейший элемент управления выносками всего с одним из обязательных членов и строкой заголовка.
 

 



```
var calloutPageElement = document.createElement("div");
var callout = CalloutManager.createNew({
   ID: "unique identifier",
   launchPoint: calloutPageElement,
   title: "callout title"
});

```

Данная конкретная выноска отображает заголовок в верхней части элемента управления, когда пользователь щелкает элемент страницы. Используйте необязательные члены для удобной и эффективной настройки внешнего вида, режима работы, положения и действий элемента управления. Элемент управления выносками имеет метод set, с помощью которого вы можете задать значение для любого параметра после создания экземпляра элемента управления.
 

 



```
callout.set({openOptions:{event: "hover"}});
```

Вы также можете задать значения для всех элементов выноски в объекте `CalloutOptions`, а затем передать этот объект методу `createNew`.
 

 



```
var calloutPageElement = document.createElement("div");
var calloutOptions = new CalloutOptions();
calloutOptions.ID = unique identifier;
calloutOptions.launchPoint = calloutPageElement;
calloutOptions.title = callout title;
var callout = CalloutManager.createNew(calloutOptions);
```


## <a name="how-to-customize-the-appearance-of-the-callout-control"></a>Настройка внешнего вида выноски
<a name="Appearance"> </a>

Управлять внешним видом выноски можно с помощью указанных ниже элементов.
 

 


|**Элемент**|**Назначение**|**Допустимые значения (полужирным шрифтом выделено значение по умолчанию)**|
|:-----|:-----|:-----|
|title|Отображение заголовка в верхней части элемента управления.|строка, **NULL**, строка с HTML-кодом|
|content|Отображение HTML в элементе управления в случае отсутствия значения для элемента `contentElement`.|строка с HTML-кодом, **NULL**, должен быть равен NULL, если для элемента `contentElement` задано значение.|
|contentElement|Отображение элемента HTML внутри элемента управления в случае отсутствия значения для элемента `content`.|любой элемент HTML, **NULL**, должен быть равен NULL, если для элемента `content` задано значение|
|contentWidth|Указание ширины (в пикселях) контейнера основной части выноски. Этот контейнер также имеет границу шириной 1 пиксель и поле шириной 15 пикселей с каждой стороны, поэтому итоговый элемент управления на 32 пикселя шире указанной вами ширины. Для свойства  `overflow` CSS элемента управления устанавливается значение `hidden`, поэтому контент, который не умещается в указанную вами ширину, обрезается. Если задать этот член для открытой выноски, изменение вступит в силу немедленно. Это не распространяется на остальные члены.  |Любое число от 240 до 610, **350** (то есть по умолчанию ширина элемента управления составляет 382 пикселя)|
|beakOrientation|Задает ориентацию стрелки или указателя выноски.|**topBottom**: ориентация, показанная на рис. 2. **Рис. 2. Стрелка выноски с ориентацией topBottom**![Стрелка выноски с ориентацией topBottom](../images/SP15_CalloutTopBottom.png)**leftRight**: ориентация, показанная на рис. 3. **Рис. 3. Стрелка выноски с ориентацией leftRight**![Стрелка выноски с ориентацией leftRight](../images/SP15_CalloutLeftRight.png)|

## <a name="how-to-customize-the-behavior-of-the-callout-control"></a>Настройка поведения элемента управления "Выноска"
<a name="Behavior"> </a>

Вы можете использовать следующие члены для управления режимом работы выноски. Начинайте с важного члена  `openOptions`, так как он позволяет вам указать, как элемент управления открывается и закрывается при взаимодействии пользователя со страницей.
 

 


|**Значения элемента `openOptions`**|**Назначение**|
|:-----|:-----|
|**{event: "click", closeCalloutOnBlur: true}**|Элемент управления выносками отображается, когда пользователь щелкает элемент  `launchPoint`, и закрывается, когда пользователь перемещает указатель за пределы элемента управления  `launchPoint`. Поскольку значение  `event` равно `click`, значение параметра  `showCloseButton` равно **true** по умолчанию и не может быть изменено. Это сочетание значений используется по умолчанию. |
| `{event: "hover", showCloseButton: true}`|Элемент управления выносками отображается, когда пользователь наводит указатель на элемент  `launchPoint`, и закрывается, когда пользователь нажимает кнопку **X** в верхнем правом углу элемента управления. Поскольку значение `event` равно `hover`, значение  `closeCalloutOnBlur` не используется и не может быть задано. |
| `{event: "click", closeCalloutOnBlur: false}`|Элемент управления выносками отображается, когда пользователь наводит указатель на элемент  `launchPoint`, и закрывается только тогда, когда пользователь нажимает кнопку **X** в верхнем правом углу элемента управления. Поскольку значение `event` равно `click`, значение параметра  `showClosebutton` равно **true** по умолчанию и не может быть изменено. |
Ниже показаны другие элементы, с помощью которых можно управлять поведением выноски.
 

 


|**Элемент**|**Назначение**|**Допустимые значения (полужирным шрифтом выделено значение по умолчанию)**|
|:-----|:-----|:-----|
|onOpeningCallback|Выполнение действий, которые должны произойти до прорисовки на странице элемента управления выносками. Поскольку объект  `Callout` требуется передать в виде параметра в предоставляемую вами функцию, вы можете использовать этот член, чтобы задать значения для любых свойств элемента управления до его прорисовки. Вы также можете использовать этот член для запуска асинхронных действий, которые добавляют или изменяют содержимое этого элемента управления. Задать значение для этого члена можно только один раз.| `function(callout /*=Callout*/) {...}`, **NULL**|
|onOpenedCallback|Выполнение действий, которые должны произойти после прорисовки на странице элемента управления выносками и полного его анимирования. Вы можете использовать этот член для работы с моделью DOM элемента управления. Задать значение для этого члена можно только один раз.| `function(callout /*=Callout*/) {...}`, **NULL**|
|onClosingCallback|Выполнение действий, которые должны произойти во время закрытия элемента управления выносками, но до его полного удаления со страницы. Задать значение для этого члена можно только один раз.| `function(callout /*=Callout*/) {...}`, **NULL**|
|onClosedCallback|Выполнение действий, которые должны произойти после закрытия элемента управления выносками и полного удаления его со страницы. Задать значение для этого члена можно только один раз.| `function(callout /*=Callout*/) {...}`, **NULL**|

## <a name="how-to-use-the-callout-control-methods"></a>Как использовать методы элемента управления "Выноска"
<a name="CalloutMethods"> </a>

Вы можете настраивать поведение выноски с помощью указанных ниже методов.
 

 


|**Метод**|**Назначение**|**Допустимые значения параметров**|
|:-----|:-----|:-----|
|set({member:value})|Задает значения элементов после того, как вы создадите экземпляр элемента управления.|Пара имя-значение, определяющая значение любого элемента выноски.```var callout = new Callout({openOptions:{event: "click"}});callout.set({openOptions:{event: "hover"}});```|
|getOrientation()|Возвращает объект `CalloutOrientation`, указывающий направление выноски. Этот объект содержит четыре логических элемента: `up`, `down`, `left` и `right`. Пока элемент управления открыт, для двух из этих значений задано значение **true**, а для двух других — **false** (например, `up` и `right`).|Нет параметров|
|addEventCallback(string eventName, CalloutCallback callback|Регистрация функции обратного вызова, которая выполняется при переходе выноски в состояние, указанное параметром `eventName`.|Параметр  `eventName` должен иметь одно из следующих значений: `opening`,  `open`,  `closing`,  `closed`. Параметр  `callback` должен быть функцией, которая принимает экземпляр элемента управления выносками в качестве своего первого параметра. |
|open()|Отображение элемента управления. Если элемент управления уже открыт или находится в процессе открытия, этот метод возвращает значение **false** и не выполняется никаких действий.|Нет параметров|
|close(bool useAnimation)|Скрытие элемента управления. Если элемент управления уже закрыт или находится в процессе закрытия, этот метод возвращает значение **false** и не выполняется никаких действий.|Логическое значение, указывающее, сопровождается ли закрытие элемента управления анимацией. По умолчанию анимация отключена.|
|toggle()|Переключение открытого/закрытого состояния элемента управления|Нет параметров|
|addAction(CallOutAction calloutAction)|Добавление нового  `CalloutAction` в массив объектов `CalloutAction` элемента управления выносками. Эти объекты определяют действия для отображения в нижнем колонтитуле элемента управления. В разделе [Добавление действий в элемент управления выносками](#AddActions) поясняется, как создавать эти объекты. Вы можете добавлять действия только после создания экземпляра элемента управления. Этот элемент управления может иметь не более трех действий, и в случае добавления большего числа действий возникает исключение. |Объект `CalloutAction`.|
|refreshActions()|Перезагрузка действий, добавленных в элемент управления. Вы можете использовать этот метод для изменения, включения или отключения действий при открытом элементе управления.|Нет параметров|

## <a name="how-to-add-actions-to-the-callout-control"></a>Как добавлять действия в элемент управления "Выноска"
<a name="AddActions"> </a>

Вы добавляете действия после создания экземпляра элемента управления выносками. Действие выноски может представлять собой отдельное действие или меню действий. Вы можете добавить в элемент управления выносками до трех действий. После создания действия выноски вы добавляете его в объект  `CalloutControl` с помощью его метода `addAction`. Этот пример действия открывает новое окно в браузере, когда пользователь щелкает текст.
 

 

```
//Create CalloutAction
var calloutAction = new CalloutAction({
            text: "Open window"
            onClickCallback: function() {                
                window.open(url);
            }
        });

//Add Action to an instance of the CalloutControl        
        myCalloutControl.addAction(calloutAction);
```

Вы также можете задать значения для всех элементов `CalloutAction` в объекте `CalloutActionOptions` и передать этот объект конструктору `CalloutAction`.
 

 



```
//Create CalloutAction
var calloutActionOptions = new CalloutActionOptions();
calloutActionOptions.text = "Open window";
actionOptions.onClickCallback = function() {
    window.open(url);
};
var calloutAction = new CalloutAction(calloutActionOptions);

//Add Action to an instance of the CalloutControl        
        myCalloutControl.addAction(calloutAction);
```

Ниже перечислены элементы, с помощью которых можно определять поведение действия выноски.
 

 


|**Элемент**|**Назначение**|**Допустимые значения (полужирным шрифтом выделено значение по умолчанию)**|
|:-----|:-----|:-----|
|text (обязательный)|Отображение текстовой подписи действия.|строка, **NULL**|
|onClickCallback|Определение действия, выполняемого, когда пользователь нажимает подпись действия выноски.| `function(calloutAction /*=CalloutAction*/) {...}`, **NULL**|
|isEnabledCallback|Определение функции обратного вызова, которая выполняется до отображения выноски и определяет, включено ли то или иное действие. Если функция возвращает значение **true**, на выноске отображается разрешенное действие. Если она возвращает значение **false**, на выноске отображается текст действия, но само действие отключается. `function(calloutAction /*=CalloutAction*/) {...}`, **NULL**|
|isVisibleCallback|Определение функции обратного вызова, которая выполняется до отображения выноски и определяет, отображается ли текст действия. Если функция возвращает значение **true**, на выноске отображается текст действия. Если она возвращает значение **false**, текст действия на выноске скрывается. Другие действия смещаются влево, занимая место скрытого действия. | `function(calloutAction /*=CalloutAction*/) {...}`, **NULL**|
|tooltip|Отображение текста при наведении указателя на текст действия выноски.|строка, **NULL**|
|disabledTooltip|Отображение текста при наведении указателя на текст отключенного действия выноски (если функция `isEnabledCallback` возвращает значение **false**).|строка, **NULL**|
|menuEntries|Определение меню действий вместо отдельного действия. В следующем разделе поясняется, как создать  `CalloutActionMenuEntry` и добавить его в объект `CalloutAction`.  |[`CalloutActionMenuEntry`, …], NULL|

### <a name="how-to-add-action-menus-to-the-callout-control"></a>Как добавлять меню действий к элементу управления "Выноска"

Когда действие выноски содержит меню вместо отдельного действия, пользователь видит рядом с текстом действия выноски стрелку вниз, как показано на рисунке 4.
 

 

**Рис. 4. Меню, отображаемое в действии выноски, когда пользователь нажимает стрелку возле подписи действия**

 

 
![Меню, отображаемое в действии выноски, когда пользователь нажимает стрелку возле подписи действия.](../images/SP15_CalloutMenu.png)
 
Вы можете создать в меню любое число элементов и добавить их в действие выноски, передав в виде массива, как значение члена  `menuEntries` объекта `CalloutAction`.
 

 



```
//Create two menu entries.
var menuEntry1 = new CalloutActionMenuEntry("Entry One", calloutActionCallbackFunction, "/_layouts/images/DOC16.GIF");
var menuEntry2 = new CalloutActionMenuEntry("Some Other Entry", calloutActionCallbackFunction, "/_layouts/images/XLS16.GIF");

//Add the menu entries to the callout action.
var calloutAction = new CalloutAction({
   text: "MENU W/ ICONS",
   menuEntries: [menuEntry1, menuEntry2]
})

//Add the callout action to the callout control.
callout.addAction(calloutAction);

```

Конструктор  `CalloutActionMenuEntry` принимает три параметра. Первые два из них являются обязательными. Третий необязателен, но может оказаться полезным, так как позволяет отобразить значок рядом с текстом.
 

 

 

- Передайте в качестве первого параметра строку для отображения текстовой подписи каждого пункта меню.
    
 
- Передайте функцию в качестве второго параметра, чтобы определить действие, которое выполняется при щелчке пользователем текста элемента меню.
    
 
- Передайте строку, содержащую URL-адрес для значка, который вы хотите отобразить слева от текстовой метки.
    
 

## <a name="how-to-use-the-calloutmanager-to-create-and-manage-instances-of-the-callout-control"></a>Как создавать экземпляры элемента управления "Выноска" и управлять ими с помощью CalloutManager
<a name="UseCalloutManager"> </a>

Одноэлементный объект  `CalloutManager` хранит ссылки на каждый объект `Callout` на странице. Он хранит каждый экземпляр элемента управления выносками в массиве ассоциативных элементов, где значение `ID` каждого элемента управления является ключом. `CalloutManager` содержит методы, помогающие создавать хранимые им объекты `Callout` и управлять ими.
 

 


|**Метод**|**Назначение**|**Допустимые значения параметров**|
|:-----|:-----|:-----|
|createNew()|Создание нового объекта  `Callout`. Когда вы делаете это,  `CalloutManager` добавляет запись для элемента управления в свой массив ассоциативных элементов, используя значение требуемого члена `ID` в качестве ключа. |Массив ассоциативных элементов, назначающий значения каждому элементу, который требуется использовать. Элементы `ID` и `launchPoint` являются обязательными.|
|createNewIfNecessary()|Создание объекта `Callout`, если объекту `launchPoint`, переданному в качестве параметра, еще не назначен элемент управления "Выноска".|Массив ассоциативных элементов, назначающий значения каждому элементу, который требуется использовать. Элементы `ID` и `launchPoint` являются обязательными.|
|getFromLaunchPoint: функция (/*@type(HTMLElement)*/launchPoint)|Получение объекта  `Callout`, связанного с предоставленным в функции элементом  `launchPoint`. Этот метод вызывает исключение, если  `launchPoint` не имеет назначенного объекта `Callout`.  |Нет параметров|
|getFromLaunchPointIfExists: функция (/*@type(HTMLElement)*/launchPoint)|Получение объекта `Callout`, связанного с объектом `launchPoint`, указанным в функции. Этот метод возвращает значение NULL, если объекту `launchPoint` не назначен объект `Callout`.|Нет параметров|
|getFromCalloutDescendant: функция (/*@type(HTMLElement)*/descendant)|Получение объекта  `Callout`, связанного с HTML-элементом, который предоставлен в выданном функцией элементе. Этим элементом может быть любой потомок элемента выноски. Например, вы можете передать значение члена  `contentElement`, назначенное при создании объекта  `Callout`. Этот метод вызывает исключение, если потомок не имеет связанного с ним объекта  `Callout`.  |Нет параметров|
|closeAll()|Закрывает все открытые объекты `Callout`. Этот метод возвращает значение true, если он закрывает хотя бы одну выноску.|Нет параметров|
|isAtLeastOneCalloutOpen()|Проверяет наличие хотя бы одной открытой выноски.|Нет параметров|

## <a name="how-to-position-the-callout-control-on-the-page"></a>Как разместить элемент управления "Выноска" на странице
<a name="Positioning"> </a>



|**Элемент**|**Назначение**|**Допустимые значения (полужирным шрифтом выделено значение по умолчанию)**|
|:-----|:-----|:-----|
|boundingBox|Указание HTML-элемента, который будет выступать в качестве эквивалента  `offsetParent` элемента управления выносками. По умолчанию стандартным значением для него будет `offsetParent` элемента управления выносками, однако вы можете использовать этот член, чтобы обеспечить правильное расположение элемента управления. Элемент управления выносками попытается расположиться таким образом, чтобы находится внутри этой рамки. Он изменит направление (с верхнего на нижнее или с левого на правой в зависимости от ориентации указателя), чтобы оставаться видимым в этой рамке. |любой HTML-элемент, **offsetParent HTML-элемента, содержащего выноску**|
|positionAlgorithm|Переопределение алгоритма размещения по умолчанию для элемента управления выносками. В следующем разделе описывается использование объекта  `calloutPositioningProxy` в целях написания алгоритмов размещения для элемента управления выносками.|**CalloutOptions.prototype.defaultPositionAlgorithm**, `function(calloutPositioningProxy) { ... }`|

### <a name="how-to-write-positioning-algorithms-with-calloutpositioningproxy"></a>Как создавать алгоритмы размещения с помощью calloutPositioningProxy

Объект  `calloutPositioningProxy` содержит методы и свойства, которые вы можете использовать, чтобы переопределить логическую схему размещения, используемую по умолчанию элементом управления выносками. Например, если вы хотите, чтобы этот элемент все время отображался ниже и правее элемента `launchPoint`, напишите следующий алгоритм размещения.
 

 

```
function alwaysGoDownAndRight(calloutPositioningProxy)  {
    calloutPositioningProxy.moveDownAndRight();
} 

```

Затем вы передаете эту функцию в качестве значения члена  `positionAlgorithm` объекта `Callout`. Вы можете сделать это при создании  `Callout` или позднее, просто задав это значение.
 

 



```
callout.set({positionAlgorithm: alwaysGoDownAndRight});

```

Вы всегда можете взглянуть на логическую схему размещения по умолчанию, запустив консоль JavaScript браузера (например, инструменты разработчика по F12 в Internet Explorer).
 

 



```
CalloutOptions.prototype.positionAlgorithm.toString()
```

Вы можете программировать логику размещения с помощью указанных ниже методов объекта `CalloutPositioningProxy`.
 

 


|**Метод**|**Описание**|
|:-----|:-----|
|isCalloutTooFarTop()|Возвращает логическое значение.|
|isCalloutTooFarRight()|Возвращает логическое значение.|
|isCalloutTooFarBottom()|Возвращает логическое значение.|
|isCalloutTooFarLeft()|Возвращает логическое значение.|
|isCalloutLeftOfHardBoundingBox()|Возвращает логическое значение. Если это значение равно **true**, левая сторона элемента управления выходит за границы элемента-контейнера. Она не видна, и пользователь не может получить доступ к ней с помощью прокрутки.|
|isCalloutRightOfHardBoundingBox()|Возвращает логическое значение. Если это значение равно **true**, правая сторона элемента управления выходит за границы элемента-контейнера. Она не видна, и пользователь не может получить доступ к ней с помощью прокрутки.|
|isCalloutAboveHardBoundingBox()|Возвращает логическое значение. Если это значение равно **true**, верхняя сторона элемента управления выходит за границы элемента-контейнера. Она не видна, и пользователь не может получить доступ к ней с помощью прокрутки.|
|isCalloutBelowHardBoundingBox()|Возвращает логическое значение. Если это значение равно **true**, нижняя сторона элемента управления выходит за границы элемента-контейнера. Она не видна, и пользователь не может получить доступ к ней с помощью прокрутки.|
|isOrientedUp()|Возвращает логическое значение.|
|isOrientedDown()|Возвращает логическое значение.|
|isOrientedLeft()|Возвращает логическое значение.|
|isOrientedRight()|Возвращает логическое значение.|
|moveUpAndRight()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|moveUpAndLeft()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|moveDownAndRight()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|moveDownAndLeft()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|moveTowardsOppositeQuadrant()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|flipHorizontal()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|flipVertical()|Не возвращает никакого значения. Изменяет направление ориентации элемента управления.|
|numberOfEdgesCollidingWithBoundingBox()|Возвращает целое число от 0 до 4, обозначающее число краев, которыми выноска соприкасается с видимым ограничивающим прямоугольником. Например, если верхняя часть элемента управления обрезается верхним краем основной части документа после вызова метода  `moveUpAndRight()`, метод  `numberOfEdgesCollidingWithBoundingBox()` возвращает число больше 1. |
Этот алгоритм размещения вынуждает элемент управления располагаться над текстом или под ним. Свойство  `isRTL` объекта `CalloutPositioningProxy` указывает, читается ли отображаемый текст справа налево. Проверяйте значение этого свойства, чтобы обеспечить правильное размещение элемента управления относительно текста на странице.
 

 



```
function examplePositionAlgorithm(calloutPositioningProxy) {
    if (!calloutPositioningProxy.isRTL) {
        calloutPositioningProxy.moveDownAndRight();
        if (calloutPositioningProxy.isCalloutTooFarBottom()) {
            calloutPositioningProxy.moveUpAndRight();
        }
    }
    else {
        calloutPositioningProxy.moveDownAndLeft();
        if (calloutPositioningProxy.isCalloutTooFarBottom()) {
            calloutPositioningProxy.moveUpAndLeft();
        }
    }
}
callout.set({positionAlgorithm: examplePositionAlgorithm});

```

Этот алгоритм размещения изменяет направление по умолчанию для элемента управления с  `upAndRight` на `downAndRight`, однако при наличии столкновений он использует стандартный алгоритм.
 

 



```
function tryDownAndRightThenGoDefault(calloutPositioningProxy) {
    if (!calloutPositioningProxy.isRTL)
        calloutPositioningProxy.moveDownAndRight();
    else
        calloutPositioningProxy.moveDownAndLeft();
    
    if (calloutPositioningProxy.numberOfEdgesCollidingWithBoundingBox() > 0)
        return CalloutOptions.prototype.positionAlgorithm.apply(this, arguments);
};
callout.set({positionAlgorithm: tryDownAndRightThenGoDefault});

```


## <a name="additional-resources"></a>Дополнительные ресурсы
<a name="bk_addresources"> </a>


-  [SharePoint: использование представлений списков, выносок и диалоговых окон в надстройках, размещаемых в SharePoint](http://code.msdn.microsoft.com/officeapps/SharePoint-Use-list-cb3e4e14)
    
 
-  [Знакомство с созданием надстроек SharePoint с размещением в SharePoint](get-started-creating-sharepoint-hosted-sharepoint-add-ins.md)
    
 
-  [Разработка пользовательского интерфейса для надстроек SharePoint](ux-design-for-sharepoint-add-ins.md)
    
 

 

 
